##### Kotlin

```Kotlin
private const val DIAL_UPPER_BOUND = 100

fun main() {
    (
        object {}.javaClass
            .getResource("/day1_part1.txt")
            ?.readText()
            ?: error("Resource not found")
        )
        .lineSequence()
        .map(String::trim)
        .filter(String::isNotEmpty)
        .map(::parseMoveDelta)
        .scan(50, ::nextPosition)
        .count { it == 0 }
        .let(::println)
}

fun parseMoveDelta(text: String): Int {
    val amount = text.drop(1).toInt()
    return when (text.first()) {
        'L' -> -amount
        'R' -> amount
        else -> 0
    }
}

fun nextPosition(position: Int, delta: Int): Int =
    (position + delta).mod(DIAL_UPPER_BOUND)
```

##### Scala

```Scala
import scala.io.Source
import scala.util.Using
import scala.util.chaining.scalaUtilChainingOps

private val DIAL_UPPER_BOUND = 100

@main def main(): Unit =
  Using.resource(Source.fromResource("day1_part1.txt"))(_.mkString)
    .linesIterator
    .map(_.trim)
    .filter(_.nonEmpty)
    .map(parseMoveDelta)
    .scanLeft(50)(nextPosition)
    .count(_ == 0)
    .pipe(println)

def parseMoveDelta(text: String): Int =
  val amount = text.drop(1).toInt
  text.head match
    case 'L' => -amount
    case 'R' => amount
    case _ => 0

def nextPosition(position: Int, delta: Int): Int =
  Math.floorMod(position + delta, DIAL_UPPER_BOUND)
```

##### Java

```Java
import static com.example.Input.INPUT;

void main() {

    int dialUpperBound = 100;

    long password =
        INPUT.stripIndent()
            .lines()
            .map(String::trim)
            .filter(line -> !line.isEmpty())
            .map(this::parseMoveDelta)
            .gather(Gatherers.scan(
                () -> 50,
                (position, delta) -> Math.floorMod(position + delta, dialUpperBound)
            ))
            .filter(it -> 0 == it)
            .count();

    IO.println(password);
}

private int parseMoveDelta(String text) {
    int amount = Integer.parseInt(text.substring(1));
    return switch (text.charAt(0)) {
        case 'L' -> -amount;
        case 'R' -> amount;
        default -> 0;
    };
}
```

##### Rust

```Rust
use std::fs;
use std::ops::Not;

const DIAL_UPPER_BOUND: i32 = 100;

fn main() {
    let password = fs::read_to_string("day1_part1.txt")
        .unwrap_or("".to_string())
        .lines()
        .map(str::trim)
        .filter(|line| line.is_empty().not())
        .map(parse_move_delta)
        .scan(50, next_position)
        .filter(|position| *position == 0)
        .count();

    println!("{password}");
}

fn parse_move_delta(text: &str) -> i32 {
    let (direction, amount_text) = text.split_at(1);
    let amount: i32 = amount_text.parse().unwrap_or(0);

    match direction {
        "L" => -amount,
        "R" => amount,
        _ => 0,
    }
}

fn next_position(position: &mut i32, delta: i32) -> Option<i32> {
    *position = (*position + delta).rem_euclid(DIAL_UPPER_BOUND);
    Some(*position)
}
```

##### Gleam

```Gleam
const input = "
R22
L2
R13
L49
...
L7
L12
L35
R50
"

pub fn main() {
  input
  |> string.split("\n")
  |> list.map(string.trim)
  |> list.filter(fn(s) { s != "" })
  |> calculate_password
  |> int.to_string
  |> io.println
}

const dial_upper_bound = 100

fn calculate_password(input: List(String)) -> Int {
  input
  |> list.map(parse_move_delta)
  |> list.scan(50, next_position)
  |> list.count(fn(pos) { pos == 0 })
}

fn next_position(position, delta) -> Int {
  let new_pos = position + delta
  new_pos % dial_upper_bound
}

fn parse_move_delta(text: String) -> Int {
  let amount = 
    text
    |> string.drop_start(1)
    |> int.parse
    |> result.unwrap(0)
  
  case string.first(text) {
    Ok("L") -> -amount
    Ok("R") -> amount
    _ -> 0
  }
}
```
