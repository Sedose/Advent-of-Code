##### Kotlin

```Kotlin
private const val DIAL_UPPER_BOUND = 100

private const val INITIAL_POSITION = 50

fun main() {
    (
        object {}.javaClass
            .getResource("/day1_part1.txt")
            ?.readText()
            ?: error("Resource not found")
        )
        .lineSequence()
        .map(String::trim)
        .filter(String::isNotEmpty)
        .flatMap(::parseClicks)
        .scan(INITIAL_POSITION, ::nextPosition)
        .count { it == 0 }
        .let(::println)
}

fun parseClicks(text: String): Sequence<Int> {
    val direction =
        when (text.first()) {
            'L' -> -1
            'R' -> 1
            else -> 0
        }
    val amount = text.drop(1).toInt()
    return generateSequence { direction }.take(amount)
}

fun nextPosition(position: Int, delta: Int): Int =
    (position + delta).mod(DIAL_UPPER_BOUND)
```

##### Rust

```Rust
use std::iter::repeat;
use std::ops::Not;

pub const INPUT: &str = r#"
R22
R26
L20
R20
---
L12
L35
R50
"#;

const DIAL_UPPER_BOUND: i32 = 100;
const INITIAL_POSITION: i32 = 50;

fn main() {
    let password = INPUT
        .lines()
        .map(str::trim)
        .filter(|line| line.is_empty().not())
        .flat_map(parse_move_deltas)
        .scan(INITIAL_POSITION, |position, delta| {
            *position = (*position + delta).rem_euclid(DIAL_UPPER_BOUND);
            Some(*position)
        })
        .filter(|position| *position == 0)
        .count();

    println!("{password}");
}

fn parse_move_deltas(text: &str) -> impl Iterator<Item = i32> {
    let (direction_text, amount_text) = text.split_at(1);
    let amount = amount_text.parse().unwrap_or(0);

    let direction = match direction_text {
        "L" => -1,
        "R" => 1,
        _ => 0,
    };

    repeat(direction).take(amount)
}
```

##### Gleam

```Gleam

const input = "
R22
L2
R13
L49
...
L7
L12
L35
R50
"

const dial_upper_bound = 100

const dial_initial_position = 50

pub fn main() {
  input
  |> string.split("\n")
  |> list.map(string.trim)
  |> list.filter(fn(line) { !string.is_empty(line) })
  |> calculate_password
  |> int.to_string
  |> io.println
}

fn calculate_password(input: List(String)) -> Int {
  input
  |> list.flat_map(parse_clicks)
  |> list.scan(dial_initial_position, next_position)
  |> list.count(fn(pos) { pos == 0 })
}

fn next_position(position, delta) -> Int {
  let new_pos = position + delta
  new_pos % dial_upper_bound
}

fn parse_clicks(line: String) -> List(Int) {
  let direction = case string.first(line) {
    Ok("L") -> -1
    Ok("R") -> 1
    _ -> 0
  }

  let amount = string.drop_start(line, 1) |> int.parse |> result.unwrap(0)

  list.repeat(direction, amount)
}
```
